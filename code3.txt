import pandas as pd
import numpy as np
from scipy import stats
from statsmodels.tsa.stattools import adfuller, grangercausalitytests
from google.cloud.bigquery import Client
import warnings

warnings.filterwarnings("ignore")


class TimeSeriesFeatureEngineering:
    def __init__(self, project_id, table, date_cutoff, unique_id="all"):
        self.client = Client(project=project_id)
        self.table = table
        self.date_cutoff = date_cutoff
        self.unique_id = unique_id
        self.data = None
        self.transformed_data = None
        self.selected_features_dict = {}

    def load_data(self):
        """Load data from BigQuery and filter by unique_id and date."""
        print("Loading data from BigQuery...")
        query = f"SELECT * FROM {self.table}"
        self.data = self.client.query(query).to_dataframe()
        self.data = self.data[
            (self.data["unique_id"] == self.unique_id) & (self.data["date"] < self.date_cutoff)
        ].reset_index(drop=True)
        print(f"Data loaded with shape: {self.data.shape}")

    def preprocess_data(self, columns):
        """Filter relevant columns and prepare the data for processing."""
        print("Preprocessing data...")
        self.data = self.data[columns].copy()
        self.data.set_index("date", inplace=True)
        self.data.sort_index(inplace=True)
        print(f"Columns selected with shape: {self.data.shape}")

    def boxcox_transform(self, columns):
        """Apply Box-Cox transformation to positive-valued columns."""
        print("Applying Box-Cox transformation...")
        transformed_data = pd.DataFrame(index=self.data.index)
        for col in columns:
            if (self.data[col] > 0).all():
                transformed_data[col], _ = stats.boxcox(self.data[col])
            else:
                print(f"Skipping Box-Cox for {col} due to non-positive values.")
        self.transformed_data = transformed_data.dropna()
        print("Box-Cox transformation completed.")

    def make_stationary(self, columns, signif=0.05, max_diff_order=2):
        """Ensure data is stationary by applying differencing where necessary."""
        print("Ensuring stationarity...")
        non_stationary = []
        for col in columns:
            if not self._is_stationary(self.transformed_data[col], signif):
                non_stationary.append(col)

        if non_stationary:
            print(f"Non-stationary columns detected: {non_stationary}")
            for _ in range(max_diff_order):
                self.transformed_data[non_stationary] = self.transformed_data[non_stationary].diff()
                self.transformed_data.dropna(inplace=True)

            # Re-check stationarity
            remaining_non_stationary = [
                col for col in non_stationary if not self._is_stationary(self.transformed_data[col], signif)
            ]
            if remaining_non_stationary:
                print(f"Warning: Some columns remain non-stationary: {remaining_non_stationary}")
        print("Stationarity ensured.")

    def perform_granger_causality(self, max_lag=12, signif=0.05):
        """Perform Granger causality tests and store significant relationships."""
        print("Performing Granger causality tests...")
        cols = self.transformed_data.columns
        causality_results = pd.DataFrame(index=cols, columns=cols)

        for col in cols:
            for row in cols:
                if col != row:
                    result = grangercausalitytests(
                        self.transformed_data[[row, col]], max_lag, verbose=False
                    )
                    p_values = [round(result[i + 1][0]["ssr_chi2test"][1], 4) for i in range(max_lag)]
                    causality_results.loc[row, col] = min(p_values)

        significant_features = causality_results.applymap(lambda x: x < signif if pd.notnull(x) else False)
        print("Granger causality tests completed.")
        return significant_features

    def select_features(self, significant_features, exclude_list, groups):
        """Select features for each group based on Granger causality results."""
        print("Selecting features based on Granger causality...")
        for group in groups:
            group_significant = significant_features[group].index[significant_features[group]]
            selected = [col for col in group_significant if col not in exclude_list] + [group]
            self.selected_features_dict[group] = selected
            print(f"Selected features for {group}: {selected}")

    def remove_highly_correlated(self, threshold=0.9):
        """Remove highly correlated features within each group."""
        print("Removing highly correlated features...")
        for group, features in self.selected_features_dict.items():
            subset = self.transformed_data[features]
            corr_matrix = subset.corr().abs()
            upper_triangle = corr_matrix.where(np.triu(np.ones(corr_matrix.shape), k=1).astype(bool))
            to_drop = [col for col in upper_triangle.columns if any(upper_triangle[col] > threshold)]
            self.selected_features_dict[group] = [f for f in features if f not in to_drop]
            print(f"Final features for {group}: {self.selected_features_dict[group]}")

    def _is_stationary(self, series, signif=0.05):
        """Perform Augmented Dickey-Fuller test for stationarity."""
        adf_result = adfuller(series, autolag="AIC")
        return adf_result[1] <= signif

    def run_pipeline(self, columns, exclude_list, groups, signif=0.05, max_diff_order=2, max_lag=12):
        """Run the entire feature engineering pipeline."""
        self.load_data()
        self.preprocess_data(columns)
        positive_columns = [col for col in columns if (self.data[col] > 0).all()]
        self.boxcox_transform(positive_columns)
        self.make_stationary(positive_columns, signif, max_diff_order)
        causality_results = self.perform_granger_causality(max_lag, signif)
        self.select_features(causality_results, exclude_list, groups)
        self.remove_highly_correlated()
        print("Pipeline completed. Final feature selection:")
        for group, features in self.selected_features_dict.items():
            print(f"{group}: {features}")


# Define parameters
columns = [
    "date", "unemployment_rate", "inflation_value", "us_interest_rate", "consumer_sentiment",
    "total_consumer_debt", "total_consumer_debt_monthlyrate", "total_group_cnt", "total_member_cnt",
    "bkt_1_M_member_perc", "bkt_1_F_member_perc", "bkt_2_M_member_perc", "bkt_2_F_member_perc",
    "bkt_3_M_member_perc", "bkt_3_F_member_perc", "bkt_4_M_member_perc", "bkt_4_F_member_perc",
    "gnrc_cnt", "jcode_cnt", "brnd_cnt", "new_drug_cnt", "jcode_allowed", "jcode_paid",
    "jcode_3k_allowed", "jcode_3k_paid", "jcode_top15_allowed", "jcode_top15_paid",
    "chronic_allowed", "chronic_paid", "acute_facility_cnt", "bh_facility_cnt", "facility_cnt",
    "non_facility_cnt", "non_acute_facility_cnt", "r_facility_cnt", "other_facility_cnt",
    "primary_care_cnt", "specialist_cnt", "physician_cnt", "nursing_cnt",
    "healthcare_construction_spending", "medical_care_cpi", "std_arme_risk_score",
    "std_arme_pmpm_pred", "mean_arme_risk_score", "mean_arme_pmpm_pred", "pme_cnt", "agesexfactor",
    "ip_pmpm", "op_pmpm", "phy_pmpm", "mh_pmpm", "ip", "phy", "op", "rx", "med_pmpm", "rx_pmpm", "total_pmpm"
]
exclude_list = ["ip_y", "op_y", "phy_y", "rx_y", "med_pmpm_y", "rx_pmpm_y", "total_pmpm_y",
                "ip_pmpm_y", "op_pmpm_y", "phy_pmpm_y", "mh_pmpm_y"]
groups = ["ip", "op", "phy", "rx", "med_pmpm", "rx_pmpm", "total_pmpm", "ip_pmpm", "op_pmpm", "phy_pmpm", "mh_pmpm"]

# Initialize and run
project_id = "anbc-hcb-dev
